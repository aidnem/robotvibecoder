package frc.robot.{{ package }};

import static edu.wpi.first.units.Units.RadiansPerSecond;
import static edu.wpi.first.units.Units.Rotations;
import static edu.wpi.first.units.Units.Volts;
import static edu.wpi.first.units.Units.VoltsPerRadianPerSecond;
import static edu.wpi.first.units.Units.VoltsPerRadianPerSecondSquared;

import coppercore.parameter_tools.LoggedTunableNumber;
import coppercore.wpilib_interface.UnitUtils;
import edu.wpi.first.units.measure.Angle;
import edu.wpi.first.units.measure.AngularVelocity;
import edu.wpi.first.units.measure.MutAngle;
import frc.robot.TestModeManager;
import frc.robot.constants.JsonConstants;
import org.littletonrobotics.junction.Logger;

/**
 * A Mechanism to keep track of the {{ name }}
 *
 * <ul>
 *   <li>Uses closed-loop TorqueCurrentFOC control
 */
public class {{ name }}Mechanism {
  {{ name }}IO io;
  {{ name }}InputsAutoLogged inputs = new {{ name }}InputsAutoLogged();
  {{ name }}OutputsAutoLogged outputs = new {{ name }}OutputsAutoLogged();

  MutAngle goalAngle = Rotations.mutable(0.0);
  MutAngle clampedGoalAngle = Rotations.mutable(0.0);

  MutAngle minAngle = JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MinMinAngle.mutableCopy();
  MutAngle maxAngle = JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MaxMaxAngle.mutableCopy();

  LoggedTunableNumber {{ name|lowerfirst }}kP;
  LoggedTunableNumber {{ name|lowerfirst }}kI;
  LoggedTunableNumber {{ name|lowerfirst }}kD;

  LoggedTunableNumber {{ name|lowerfirst }}kS;
  LoggedTunableNumber {{ name|lowerfirst }}kV;
  LoggedTunableNumber {{ name|lowerfirst }}kA;
  LoggedTunableNumber {{ name|lowerfirst }}kG;

  LoggedTunableNumber {{ name|lowerfirst }}CruiseVelocity;
  LoggedTunableNumber {{ name|lowerfirst }}ExpokV;
  LoggedTunableNumber {{ name|lowerfirst }}ExpokA;

  LoggedTunableNumber {{ name|lowerfirst }}TuningSetpointRotations;
  LoggedTunableNumber {{ name|lowerfirst }}TuningOverrideVolts;

  public {{ name }}Mechanism({{ name }}IO io) {
    {{ name|lowerfirst }}kP =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}kP", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}KP);
    {{ name|lowerfirst }}kI =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}kI", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}KI);
    {{ name|lowerfirst }}kD =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}kD", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}KD);

    {{ name|lowerfirst }}kS =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}kS", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}KS);
    {{ name|lowerfirst }}kV =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}kV", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}KV);
    {{ name|lowerfirst }}kA =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}kA", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}KA);
    {{ name|lowerfirst }}kG =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}kG", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}KG);

    {{ name|lowerfirst }}CruiseVelocity =
        new LoggedTunableNumber(
            "{{ name }}Tunables/{{ name|lowerfirst }}CruiseVelocity",
            JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MotionMagicCruiseVelocityRotationsPerSecond);
    {{ name|lowerfirst }}ExpokV =
        new LoggedTunableNumber(
            "{{ name }}Tunables/{{ name|lowerfirst }}ExpokV", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MotionMagicExpo_kV);
    {{ name|lowerfirst }}ExpokA =
        new LoggedTunableNumber(
            "{{ name }}Tunables/{{ name|lowerfirst }}ExpokA", JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MotionMagicExpo_kA);

    {{ name|lowerfirst }}TuningSetpointRotations =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}TuningSetpointRotations", 0.0);
    {{ name|lowerfirst }}TuningOverrideVolts =
        new LoggedTunableNumber("{{ name }}Tunables/{{ name|lowerfirst }}TuningOverrideVolts", 0.0);

    this.io = io;
  }

  /**
   * Runs periodically when the robot is enabled
   *
   * <p>Does NOT run automatically! Must be called by the subsystem
   */
  public void periodic() {
    sendGoalAngleToIO();

    io.updateInputs(inputs);
    io.applyOutputs(outputs);

    Logger.processInputs("{{ name }}/inputs", inputs);
    Logger.processInputs("{{ name }}/outputs", outputs);
  }

  public void setBrakeMode(boolean brake) {
    io.setBrakeMode(brake);
  }

  /** This method must be called from the subsystem's test periodic! */
  public void testPeriodic() {
    switch (TestModeManager.getTestMode()) {
      case {{ name }}ClosedLoopTuning:
        io.setOverrideMode(false);
        LoggedTunableNumber.ifChanged(
            hashCode(),
            (pid) -> {
              io.setPID(pid[0], pid[1], pid[2]);
            },
            {{ name|lowerfirst }}kP,
            {{ name|lowerfirst }}kI,
            {{ name|lowerfirst }}kD);

        LoggedTunableNumber.ifChanged(
            hashCode(),
            (ff) -> {
              io.setFF(ff[0], ff[1], ff[2], ff[3]);
            },
            {{ name|lowerfirst }}kS,
            {{ name|lowerfirst }}kV,
            {{ name|lowerfirst }}kA,
            {{ name|lowerfirst }}kG);

        LoggedTunableNumber.ifChanged(
            hashCode(),
            (maxProfile) -> {
              io.setMaxProfile(
                  RadiansPerSecond.of(0.0),
                  VoltsPerRadianPerSecondSquared.ofNative(maxProfile[0]),
                  VoltsPerRadianPerSecond.ofNative(maxProfile[1]));
            },
            {{ name|lowerfirst }}ExpokA,
            {{ name|lowerfirst }}ExpokV);

      case SetpointTuning:
        // Allow setpointing in {{ name }}ClosedLoopTuning and SetpointTuning
        LoggedTunableNumber.ifChanged(
            hashCode(),
            (setpoint) -> {
              setGoalAngle(Rotations.of(setpoint[0]));
            },
            {{ name|lowerfirst }}TuningSetpointRotations);
        break;
      case {{ name }}VoltageTuning:
        LoggedTunableNumber.ifChanged(
            hashCode(),
            (setpoint) -> {
              io.setOverrideVoltage(Volts.of(setpoint[0]));
            },
            {{ name|lowerfirst }}TuningOverrideVolts);
        io.setOverrideMode(true);
        break;
      default:
        break;
    }
  }

  public void sendGoalAngleToIO() {
    updateClampedGoalAngle();

    io.set{{ name }}GoalPos(clampedGoalAngle);
  }

  /**
   * Based on the bounds previously set, clamp the last set goal height to be between the bounds.
   *
   * <p>If the goal height is outside of the bounds and the bounds are expanded, this function will
   * still behave as expected, as the mechanism remembers its unclamped goal height and will attempt
   * to get there once it is allowed.
   */
  private void updateClampedGoalAngle() {
    clampedGoalAngle.mut_replace(UnitUtils.clampMeasure(goalAngle, minAngle, maxAngle));

    Logger.recordOutput("{{ name }}/clampedGoalAngle", clampedGoalAngle);
  }

  /**
   * Set the goal angle the {{ name|lowerfirst }} will to control about.
   *
   * <p>This goal angle will be clamped by the allowed range of motion
   *
   * @param goalAngle The new goal angle
   */
  public void setGoalAngle(Angle goalAngle) {
    this.goalAngle.mut_replace(goalAngle);

    Logger.recordOutput("{{ name }}/goalAngle", goalAngle);
  }

  /**
   * Sets the minimum and maximum allowed angles that the {{ name|lowerfirst }} may target.
   *
   * <p>When not in override mode, the goal angle of the {{ name|lowerfirst }} will be clamped to be between these
   * values before it is sent to the IO. When these clamps change, the original goal angle is
   * clamped to be within the new bounds.
   *
   * @param minAngle The minimum angle, which will be clamped between {{ name|lowerfirst }}MinMinAngle and
   *     {{ name|lowerfirst }}MaxMaxAngle before being applied
   * @param maxAngle The maximum angle, which will be clamped between {{ name|lowerfirst }}MinMinAngle and
   *     {{ name|lowerfirst }}MaxMaxAngle before being applied
   */
  public void setAllowedRangeOfMotion(Angle minAngle, Angle maxAngle) {
    setMinAngle(minAngle);
    setMaxAngle(maxAngle);
  }

  /**
   * Sets the minimum allowed angle that the {{ name|lowerfirst }} may target.
   *
   * <p>When not in override mode, the goal angle of the {{ name|lowerfirst }} will be clamped to be between these
   * values before it is sent to the IO. When these clamps change, the original goal angle is
   * clamped to be within the new bounds.
   *
   * @param minAngle The minimum angle, which will be clamped between {{ name|lowerfirst }}MinMinAngle and
   *     {{ name|lowerfirst }}MaxMaxAngle before being applied
   */
  public void setMinAngle(Angle minAngle) {
    this.minAngle.mut_replace(
        UnitUtils.clampMeasure(
            minAngle,
            JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MinMinAngle,
            JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MaxMaxAngle));

    Logger.recordOutput("{{ name }}/minAngle", minAngle);
  }

  /**
   * Sets the maximum allowed angle that the {{ name|lowerfirst }} may target.
   *
   * <p>When not in override mode, the goal angle of the {{ name|lowerfirst }} will be clamped to be between these
   * values before it is sent to the IO. When these clamps change, the original goal angle is
   * clamped to be within the new bounds.
   *
   * @param maxAngle The maximum angle, which will be clamped between {{ name|lowerfirst }}MinMinAngle and
   *     {{ name|lowerfirst }}MaxMaxAngle before being applied
   */
  public void setMaxAngle(Angle maxAngle) {
    this.maxAngle.mut_replace(
        UnitUtils.clampMeasure(
            maxAngle,
            JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MaxMaxAngle,
            JsonConstants.{{ name|lowerfirst }}Constants.{{ name|lowerfirst }}MaxMaxAngle));

    Logger.recordOutput("{{ name }}/maxAngle", maxAngle);
  }

  /**
   * Get the current angle of the {{ name|lowerfirst }}
   *
   * @return
   */
  public Angle get{{ name }}Angle() {
    return inputs.{{ name|lowerfirst }}Position;
  }

  /**
   * Get the current angular velocity of the {{ name|lowerfirst }}
   *
   * @return The current velocity of the {{ name|lowerfirst }}, according to the {{ encoder }}
   */
  public AngularVelocity get{{ name }}Velocity() {
    return inputs.{{ name|lowerfirst }}Velocity;
  }

  /**
   * Check whether or not the {{ encoder}} is currently connected.
   *
   * <p>"Connected" means that last time the position and velocity status signals were refreshed, the status code
   * was OK
   *
   * @return True if connected, false if disconnected
   */
  public boolean is{{ encoder|upperfirst }}Connected() {
    return inputs.is{{ encoder|upperfirst }}Connected;
  }

  /**
   * Get a reference to the {{ name|lowerfirst }}'s IO. This should be used to update PID, motion profile, and feed
   * forward gains, and to set brake mode/disable motors. This method exists to avoid the need to
   * duplicate all of these functions between the mechanism and the IO.
   *
   * @return the {{ name|lowerfirst }} mechanism's IO
   */
  public {{ name }}IO getIO() {
    return io;
  }

  /** Set whether or not the motor on the {{ name|lowerfirst }} should be disabled */
  public void setMotorsDisabled(boolean disabled) {
    io.setMotorsDisabled(disabled);
  }

  /** Get the current unclamped angle of the {{ name|lowerfirst }} */
  public Angle get{{ name }}GoalAngle() {
    return goalAngle;
  }
}